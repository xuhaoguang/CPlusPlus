1.**解释C++中四中运算符转化及其不同点**
* const\_cast:  
	>* 使用const_cast去掉const属性，其实并不是真的改变原类类型(或基本类型)的const属性，它只是又提供了一个接口(指针或引用)，使你可以通过这个接口来改变类型的值。也许这也是const_cast只能转换指针或引用的一个原因吧 
	>* 使用const_cast添加const属性，也是提供了一个接口，来不让修改其值，不过个人感觉这个添加const的操作没有什么实际的用途。
	```c++
	    /*
	     * const_cast
	     * 1 常量指针转非常量指针
	     * 2 常量引用转非常量引用
	     * 3 注意：不可以通过const_cast将常量对象或者常量基本类型转成非常量
	    */
	     
	    //常量指针转非常量指针
	    //------------指针指向类-------------
	    const A* p1 = new A();
	    cout << p1->num << endl; // 0
	    //p1->num = 100; //ERROR: const常量不允许修改属性成员值
	
	    A* p2 = const_cast<A*>(p1); //去除const成员，此时p2和p1指向的是同一个变量
	    cout << p1->num << "\t" << p2->num << endl; // 0, 0
	    p2->num = 100; //此时p2将p1的const属性去除了，因此可以修改属性成员值
	    cout << p1->num << "\t" << p2->num << endl; // 100, 100 
	    
	    //------------指针指向基本类型-------------
	    const int i = 100;
	    //i = 200; //ERROR
	    int* j = const_cast<int*>(&i);
	    *j = 200;
	    cout << i << "\t" << *j << endl; //200, 200
	    
	
	    //常量引用转非常量引用
	    A a0;
	    const A& a1 = a0;
	    //a1.num = 200; //ERROR
	    cout << a0.num << "\t" << a1.num << "\t" << endl; //0, 0
	    A& a2 = const_cast<A&>(a1);
	    a2.num = 200;
	    cout << a0.num << "\t" << a1.num << "\t" << a2.num << endl; //200, 200, 200
	
	```
    > const\_cast和mutable的比较  
      const\_cast:  
        1) 强制去掉对象的const属性。   
        2) 缺点：对const对象，调用包含const_cast的const成员函数，属于未定义行为.  
      mutable:  
        1) 使用场景：对可能要发生变化的成员前，加上存储描述符mutable。    
        2) 实质：对加了mutable的成员，无视所有const声明。 

* static\_cast 
---
---
2.**C++中static的作用**
* 在函数体内，一个被声明为static变量在这一函数被调用的过程中维持其值不变(该变量存储在静态变量区)。
* 在模块内(但在函数体外)，一个被声明为静态的变量可以被模块内所有的函数访问，但是不能被模块外其他函数访问，它是一个本地的全局变量。
* 在模块内，一个被声明为静态的函数只可能被这一个模块内的其他函数调用，这个函数被限制在声明它模块的本地范围内使用。
> * 1.static变量必须在类外初始化，可以在类内声明，因为static优先于类存在
> * 2.static变量可以被类或者类的对象调用
> * 3.static变量可以被private修饰
> * 4.类的静态成员变量必须先初始化再使用。
> * 5.类的非静态成员函数可以调用用静态成员函数，但反之不能。
> * 6.静态成员函数中不能引用非静态成员。
---
---
3. **关键字volatile的作用**
> 一个定义为volatile的变量，表示这个变量的取值可能会被意想不到的随意改变，因此编译器在用到这个变量的时候都必须去内存中重新读取这个变量的值，而不是使用保存在寄存器中的卑职值.  
> 下面给出常见的例子  
> 1 多进程应用程序中被几个任务共享的额变量  
> 2 并行设备的硬件寄存器(如状态寄存器)  
> 3 一个中断服务子程序中会访问到的非自动变量
---
---
4. **struct和class的区别**, (这个问题有两种情况下需要考虑下面两种情况)
> * C语言中的struct和C++中的class的区别:  
    >> * 1 struct是作为一种复杂数据类型的定义，只用于封装数据定义成员变量，而不能定义成员函数  
    >> * 2 class是类，是用于面向对象编程的重要元素
> * C++语言中的struct和C++中的class的区别:
    >> * 1 二者都可以用于定义成员变量和成员函数，都可以用于面向对象编程  
    >> * 2 对于成员访问权限以及继承方式，class中默认是private，而struct中则是默认为public  
    >> * 3 class可以用于模板编程，而struct不可以
---
---
4. **与全局对象对象相比，使用静态数据成员有什么优势**
> * 静态数据成员没有进入程序的全局名字空间，因此不存在在程序中其他全局名字冲突的可能性
> * 使用静态数据成员可以隐藏信息，因为静态成员可以是private成员，而全局对象不能是private
---
---
5. **类成员变量的初始化和赋值的区别**
> * 当类成员是const时，必须使用初始化方法
```c++
class A{
public:
    const int a;
    
    /*
    A(int x){
        a = x; //ERROR 编译错误
    } 
    */
    
    A(int x) : a(x){

    } 
}; 
```
> * 当类成员是引用类型时，必须使用初始化方法
```c++
class B{
public:
    int & a;
    /* 
    B(int x){ //ERROR 编译错误
        a = x;
    } 
    */
    
    B(int x) : a(x){

    } 
};

```
> * 当构造函数需要调用基类的构造函数时，需要使用初始化方法
```c++
class Base{
public:
    Base(int x){
        a = x;
    } 

private:
    int a;
};

//当类需要调用基类的构造函数，需要使初始化方法
class Derived : public Base{
public:
    int b;
    /*
    Derived(int _a, int _b){ //ERROR 编译错误，因为a是Base类的private成员，所以不能显示赋值
        a = _a;
        b = _b;
    }
    */
    Derived(int _a, int _b) : Base(_a), b(_b){ //TRUE 通过初始化的方式是可以完成
    }
};
```
> * 其他情况下二者没有什么特别大的区别
---
---
6. **C++中空类默认会产生哪些类成员函数**
* 默认构造函数和赋值构造函数，他们被用于类的对象的构造过程
* 析构函数，被用于类的对象的析构过程
* 赋值函数，被用于同类对象的赋值过程
* 取值函数，当对类对象进行取地址&时，此函数被调用
---
---
7. **重载和重写之间有什么区别**
* 重载是编写一个与一直函数同名但是参数表不同(参数数量和参数类型不同)的方法，具有以下特征：
    * 方法名想相同
    * 参数列表必须不相同，与参数列表顺序无关
    * 返回值类型可以不相同
* 重写是派生类重写基类的虚函数，具有以下特征：
    * 只有虚方法和抽象方法才能被重写
    * 相同的函数名
    * 相同的参数列表
    * 相同的返回值类型
---
---
8. **public、protected、private继承的区别**
* public继承是一种接口继承，子类可以代替父类完成父类接口中所声明的行为，public继承会保留父类中成员的可见性不变，父类是public，子类也是public
* protected继承是一种实现继承，子类不能代替父类完成父类接口中所声明的行为，父类是public，子类是protected
* private继承是一种实现继承，子类不能代替父类完成父类接口声明的行为，父类的所有属性和函数都会被转换成private
---
---
9. **C++中从源码到可运行程序经历的过程**
> 1. **预编译**：这一步的工作由预编译器负责，主要是用来处理一些#define，#id、#endif等命令，同时会递归处理#include指令，用被包含的文件替换这个预编译指令。这个阶段是将.c文件经过预编译变为.i文件。
> 2. **编译**：这一步由编译器负责，由词法分析、语法分析、语义分析、优化和生成汇编代码五个部分组成。这个阶段生成汇编文件，是将.i文件生成.s文件。
> 3. **汇编**：这一步由汇编器负责完成，将汇编语言转换成机器可以执行的语言，汇编文件经过汇编，编程目标文件，这个节点将.s文件生成.o文件。
> 4. **链接**：链接是将之前生成的一些目标文件链接起来，链接器主要负责地址重分配、符号名称绑定和重定位。
---
---
10. **软件调用层次**
> 1. 最上层是应用层，不管是浏览器、游戏还是我们使用的各种开发工具，都是应用层软件；
> 2. 第二层是操作系统的运行库，我们在软件系统中调用系统API，比如文件的读写，就是调用了第二层提供的相应服务，这种调用通过操作系统的API完成，他沟通了应用层和操作系统的运行库，不同操作系统的运行库提供了不同的底层实现，但是对应用层提供的API总是一样的。
> 3. 第三层是操作系统内核，操作系统通过调用系统调用来调用系统内核提供的函数，系统调用是通过终端来完成的，涉及到堆栈的保存与恢复，频繁的系统调用会影响性能。
> 4. 第四层是硬件层，程序无法直接访问这一层，只有操作系统的内核，通过硬件厂商提供的接口才能访问。
