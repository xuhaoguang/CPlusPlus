1.**解释C++中四中运算符转化及其不同点**
* const\_cast:  
	>* 使用const_cast去掉const属性，其实并不是真的改变原类类型(或基本类型)的const属性，它只是又提供了一个接口(指针或引用)，使你可以通过这个接口来改变类型的值。也许这也是const_case只能转换指针或引用的一个原因吧 
	>* 使用const_case添加const属性，也是提供了一个接口，来不让修改其值，不过个人感觉这个添加const的操作没有什么实际的用途。
	```c++
	    /*
	     * const_cast
	     * 1 常量指针转非常量指针
	     * 2 常量引用转非常量引用
	     * 3 注意：不可以通过const_cast将常量对象或者常量基本类型转成非常量
	    */
	     
	    //常量指针转非常量指针
	    //------------指针指向类-------------
	    const A* p1 = new A();
	    cout << p1->num << endl; // 0
	    //p1->num = 100; //ERROR: const常量不允许修改属性成员值
	
	    A* p2 = const_cast<A*>(p1); //去除const成员，此时p2和p1指向的是同一个变量
	    cout << p1->num << "\t" << p2->num << endl; // 0, 0
	    p2->num = 100; //此时p2将p1的const属性去除了，因此可以修改属性成员值
	    cout << p1->num << "\t" << p2->num << endl; // 100, 100 
	    
	    //------------指针指向基本类型-------------
	    const int i = 100;
	    //i = 200; //ERROR
	    int* j = const_cast<int*>(&i);
	    *j = 200;
	    cout << i << "\t" << *j << endl; //200, 200
	    
	
	    //常量引用转非常量引用
	    A a0;
	    const A& a1 = a0;
	    //a1.num = 200; //ERROR
	    cout << a0.num << "\t" << a1.num << "\t" << endl; //0, 0
	    A& a2 = const_cast<A&>(a1);
	    a2.num = 200;
	    cout << a0.num << "\t" << a1.num << "\t" << a2.num << endl; //200, 200, 200
	
	```
    > const\_cast和mutable的比较  
      const\_cast:  
        1) 强制去掉对象的const属性。   
        2) 缺点：对const对象，调用包含const_cast的const成员函数，属于未定义行为.  
      mutable:  
        1) 使用场景：对可能要发生变化的成员前，加上存储描述符mutable。    
        2) 实质：对加了mutable的成员，无视所有const声明。 

* static\_cast 
---
---
2.**C++中static的作用**
* 在函数体内，一个被声明为static变量在这一函数被调用的过程中维持其值不变(该变量存储在静态变量区)。
* 在模块内(但在函数体外)，一个被声明为静态的变量可以被模块内所有的函数访问，但是不能被模块外其他函数访问，它是一个本地的全局变量。
* 在模块内，一个被声明为静态的函数只可能被这一个模块内的其他函数调用，这个函数被限制在声明它模块的本地范围内使用。
> * 1.static变量必须在类外初始化，可以在类内声明，因为static优先于类存在
> * 2.static变量可以被类或者类的对象调用
> * 3.static变量可以被private修饰
> * 4.类的静态成员变量必须先初始化再使用。
> * 5.类的非静态成员函数可以调用用静态成员函数，但反之不能。
> * 6.静态成员函数中不能引用非静态成员。
---
---
3. **关键字volatile的作用**
> 一个定义为volatil的变量，表示这个变量的取值可能会被意想不到的随意改变，因此编译器在用到这个变量的时候都必须去内存中重新读取这个变量的值，而不是使用保存在寄存器中的卑职值.  
> 下面给出常见的例子  
> 1 多进程应用程序中被几个任务共享的额变量  
> 2 并行设备的硬件寄存器(如状态寄存器)  
> 3 一个中断服务子程序中会访问到的非自动变量
---
---
4. **struct和class的区别**, (这个问题有两种情况下需要考虑下面两种情况)
> * C语言中的struct和C++中的class的区别:
    >> * 1 struct是作为一种复杂数据类型的定义，只用于封装数据定义成员变量，而不能定义成员函数  
    >> * 2 class是类，是用于面向对象编程的重要元素
> * C++语言中的struct和C++中的class的区别:
    >> * 1 二者都可以用于定义成员变量和成员函数，都可以用于面向对象编程  
    >> * 2 对于成员访问权限以及继承方式，class中默认是private，而struct中则是默认为public  
    >> * 3 class可以用于模板编程，而struct不可以
---
---
4. **与全局对象对象相比，使用静态数据成员有什么优势**
> * 静态数据成员没有进入程序的全局名字空间，因此不存在在程序中其他全局名字冲突的可能性
> * 使用静态数据成员可以隐藏信息，因为静态成员可以是private成员，而全局对象不能是private
---
---
5. **类成员变量的初始化和赋值的区别**
> * 当类成员是const时，必须使用初始化方法
```c++
class A{
public:
    const int a;
    
    /*
    A(int x){
        a = x; //ERROR 编译错误
    } 
    */
    
    A(int x) : a(x){

    } 
}; 
```
> * 当类成员是引用类型时，必须使用初始化方法
```c++
class B{
public:
    int & a;
    /* 
    B(int x){ //ERROR 编译错误
        a = x;
    } 
    */
    
    B(int x) : a(x){

    } 
};

```
> * 当构造函数需要调用基类的构造函数时，需要使用初始化方法
```c++
class Base{
public:
    Base(int x){
        a = x;
    } 

private:
    int a;
};

//当类需要调用基类的构造函数，需要使初始化方法
class Derived : public Base{
public:
    int b;
    /*
    Derived(int _a, int _b){ //ERROR 编译错误，因为a是Base类的private成员，所以不能显示赋值
        a = _a;
        b = _b;
    }
    */
    Derived(int _a, int _b) : Base(_a), b(_b){ //TRUE 通过初始化的方式是可以完成
    }
};
```
> * 其他情况下二者没有什么特别大的区别
---
---
6. **C++中空类默认会产生哪些类成员函数**
* 默认构造函数和赋值构造函数，他们被用于类的对象的构造过程
* 析构函数，被用于类的对象的析构过程
* 赋值函数，被用于同类对象的赋值过程
* 取值函数，当对类对象进行取地址&时，此函数被调用
---
---
7. **重载和重写之间有什么区别**
* 重载是编写一个与一直函数同名但是参数表不同(参数数量和参数类型不同)的方法，具有以下特征：
    * 方法名想相同
    * 参数列表必须不相同，与参数列表顺序无关
    * 返回值类型可以不相同
* 重写是派生类重写基类的虚函数，具有以下特征：
    * 只有虚方法和抽象方法才能被重写
    * 相同的函数名
    * 相同的参数列表
    * 相同的返回值类型
---
---
8. **public、protected、private继承的区别**
* public继承是一种借口继承，子类可以代替父类完成父类接口中所声明的行为，public继承会保留父类中成员的可见性不变，父类是public，子类也是public
* protected继承是一种实现继承，子类不能代替父类完成父类接口中所声明的行为，父类是public，子类是protected
* private继承是一种实现继承，子类不能代替父类完成父类接口声明的行为，父类的所有属性和函数都会被转换成private
---
---
